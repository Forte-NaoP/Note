# 네트워크 질문 모음

---

### 1. OSI 7 계층과 각 계층 설명

1. **물리 계층 (Physical):** 전기 신호, 광신호 등 물리적 매체를 통해 비트를 전송
2. **데이터 링크 계층 (Data Link):** 프레임 단위로 데이터를 전달하며, MAC 주소를 기반으로 오류 검출 및 수정, 스위치가 동작
3. **네트워크 계층 (Network):** 패킷(데이터그램) 단위의 전송, IP 주소를 통한 라우팅 및 논리적 주소 지정
4. **전송 계층 (Transport):** TCP/UDP를 통해 신뢰성 있는 전송(또는 비신뢰성 전송)을 제공하며, 포트 번호로 애플리케이션을 구분, 세그먼테이션 및 재조립 수행
5. **세션 계층 (Session):** 통신 세션의 설정, 관리, 종료를 담당
6. **표현 계층 (Presentation):** 데이터 형식 변환, 암호화/복호화, 압축 등 데이터 표현 방식 처리
7. **응용 계층 (Application):** 최종 사용자에게 서비스를 제공하며, HTTP, FTP, SMTP 등 프로토콜이 해당

---

### 2. TCP/IP 프로토콜과 각 계층 설명

1. **응용 계층:** HTTP, FTP, SMTP, DNS 등 사용자와 직접 상호작용하는 프로토콜 제공
2. **전송 계층:** TCP(연결 지향, 신뢰성 보장)와 UDP(비연결성, 오버헤드 적음)를 통해 데이터의 흐름 및 오류 제어 수행
3. **인터넷 계층:** IP를 기반으로 패킷 전달, 라우팅 및 논리적 주소 부여
4. **네트워크 인터페이스 계층:** 실제 물리적 네트워크를 통해 데이터 프레임을 전송 (OSI의 물리 및 데이터 링크 계층에 해당)

---

### 3. TCP의 특징

연결 수립 후 데이터의 신뢰성을 보장하기 위해 재전송, 순서 제어, 오류 검출 등의 메커니즘을 갖추고 있으며, 전이중(Full Duplex) 통신이 가능하다.

---

### 4. SSL

- SSL(현재는 TLS로 발전)은 애플리케이션과 전송 계층 사이 또는 전송 계층 내에서 작동하며, 데이터 암호화, 무결성 검증, 인증 등을 통해 안전한 통신을 제공한다.

---

아래는 TCP 연결 수립과 종료 시 사용되는 3-way Handshake와 4-way Handshake의 동작 과정을 보다 상세하게 설명한 내용입니다.

---

### 5. TCP 3-way Handshake

1. **SYN 전송 (클라이언트 -> 서버):**

   - **동작:** 클라이언트는 연결 요청을 위해 TCP 헤더에 SYN 플래그를 설정한 세그먼트를 전송한다.
   - **세부 내용:** 클라이언트는 임의의 초기 시퀀스 번호(ISN)를 선택하여 이후 데이터의 순서를 관리하는 데 사용한다.

2. **SYN-ACK 응답 (서버 -> 클라이언트):**

   - **동작:** 서버는 클라이언트의 SYN 세그먼트를 수신한 후, 연결 요청을 수락하는 의미로 SYN과 ACK 플래그가 모두 설정된 세그먼트를 클라이언트로 전송한다.
   - **세부 내용:**
     - 서버는 자신만의 초기 시퀀스 번호를 선택하여 세그먼트에 포함시킨다.
     - 동시에, 클라이언트가 보낸 시퀀스 번호에 대한 확인 응답(ACK 번호 = 클라이언트 ISN + 1)을 전송함.

3. **ACK 전송 (클라이언트 -> 서버):**
   - **동작:** 클라이언트는 서버의 SYN-ACK 세그먼트를 수신하면, ACK 플래그가 설정된 세그먼트를 서버에 전송하여 서버의 시퀀스 번호를 확인.
   - **세부 내용:** 이 ACK에는 서버의 초기 시퀀스 번호에 대해 ACK 번호 = 서버 ISN + 1이 포함되며, 양측은 통신에 필요한 초기 상태(시퀀스 번호, 확인 번호 등)를 동기화한다.

---

### 6. TCP 4-way Handshake

1. **첫 번째 FIN 전송 (예: 클라이언트 -> 서버):**

   - **동작:** 연결 종료를 원하는 쪽이 FIN 플래그가 설정된 세그먼트를 전송한다.
   - **세부 내용:** 이 FIN 세그먼트는 해당 쪽이 더 이상 데이터를 전송하지 않겠다는 의사를 나타내며, 현재까지 전송한 데이터의 시퀀스 번호를 포함한다.

2. **ACK 응답 (서버 -> 클라이언트):**

   - **동작:** 서버는 클라이언트의 FIN 세그먼트를 수신하고, 즉시 ACK 플래그가 설정된 세그먼트를 전송하여 FIN 세그먼트를 확인한다.
   - **세부 내용:** 서버는 클라이언트 방향의 데이터 전송을 종료하고, 이후 자신의 데이터 전송은 가능하도록 'half-close' 상태로 전환한다.

3. **두 번째 FIN 전송 (서버 → 클라이언트):**

   - **동작:** 서버가 자신의 데이터 전송을 모두 완료하면, FIN 플래그가 설정된 세그먼트를 클라이언트로 전송하여 자신의 종료 의사를 전달한다.
   - **세부 내용:** 이 세그먼트에는 서버의 마지막 데이터 시퀀스 번호가 포함되어, 클라이언트가 이를 확인할 수 있도록 한다.

4. **최종 ACK 전송 (클라이언트 → 서버):**
   - **동작:** 클라이언트는 서버의 FIN 세그먼트를 수신한 후, ACK 플래그가 설정된 세그먼트를 전송하여 서버의 FIN을 확인한다.
   - **세부 내용:** 이 ACK 전송 후, 클라이언트는 일정 기간(TIME_WAIT 상태) 동안 대기하며, 지연된 패킷이나 중복 전송에 대비한 후 최종적으로 연결을 완전히 종료한다.

---

### 7. TCP 연결 끊김 탐지

- TCP는 재전송 타이머와 ACK 미수신 시 타임아웃을 통해 연결 상태를 모니터링합니다. 또한, Keep-Alive 기능 등을 통해 비정상적인 연결 종료를 탐지한다.

---

### 8. HTTP의 특징

- HTTP는 기본적으로 텍스트 기반의 비상태성(Stateless) 프로토콜로, 요청-응답 방식으로 통신한다. 평문 전송을 하기 때문에 보안에 취약하다.

---

### 9. `www.example.com` 접속 과정

1. 클라이언트는 DNS 조회(대부분 UDP, 필요시 TCP)를 통해 도메인을 IP 주소로 변환
2. 변환된 IP 주소로 TCP 3-way Handshake 및 TLS Handshake를 통해 보안 연결 수립
3. 로드 밸런서가 있다면, 요청을 분산하여 실제 웹 서버로 전달
4. 웹 서버는 요청을 처리 후 응답 데이터를 TCP 연결을 통해 전송

---

### 10. GET과 POST의 차이점

- GET: 데이터 조회용으로, URL에 파라미터를 포함하며 요청이 캐시될 수 있다. 데이터를 헤더에 포함하며, 요청 길이 제한이 존재한다.
- POST는 데이터를 서버에 제출하여 상태 변화를 유도하며, 본문에 데이터를 포함합니다.

---

### 11. TCP와 UDP의 차이

- TCP: 연결 지향, 패킷 손실 및 손상 처리, 혼잡 제어, 흐름 제어
- UDP: 비연결성, 간단한 패킷 구조, 추가 처리 없음

---

### 12. SYN Flooding 공격 설명 및 방어 방법

- **설명:** 공격자가 다수의 SYN 패킷을 전송하여 서버의 미완료 연결 큐(half-open connections)를 소진시킴으로써 정상 사용자의 연결을 방해하는 서비스 거부(DoS) 공격.
- **방어 방법:** SYN Cookies 사용, 연결 큐 크기 확장, 방화벽 및 라우터에서의 패킷 필터링, 비정상 트래픽 감시 등을 적용할 수 있다.

---

### 13. 로드 밸런싱

- 로드 밸런서는 요청 분산, 부하 감소, 고가용성 및 확장성을 제공하며, 라운드 로빈, 가중치 기반, IP 해시 등의 알고리즘을 사용해 트래픽을 분배한다.

---

### 14. 싱글스레드 서버와 멀티스레드 서버 예시

- **싱글스레드 예시:** Node.js 기반 서버 – 이벤트 루프를 이용해 단일 스레드 내에서 비동기 처리를 수행
- **멀티스레드 예시:** Apache HTTP Server(Worker MPM), Tomcat – 각각 다수의 스레드를 생성하여 동시 요청을 처리

---

### 15. 흐름제어 방식 및 대표적 방식

- TCP에서 슬라이딩 윈도우 알고리즘은 수신측의 버퍼 상황에 따라 전송 가능한 데이터 양을 동적으로 조절하여, 과도한 데이터 전송으로 인한 패킷 손실을 방지한다.

---

### 16. 서브네팅(Subnetting)

#### 1. 개념

- **정의:**  
  하나의 큰 네트워크(예: 192.168.1.0/24)를 여러 개의 작은 네트워크로 나누어 관리하는 기법.

- **필요성:**
  - **효율적 IP 주소 관리:** 제한된 IP 주소 자원을 적절하게 분배 가능.
  - **보안 강화:** 각 서브넷을 별도의 보안 정책으로 관리하여 내부 네트워크를 분리할 수 있다.
  - **네트워크 성능 향상:** 브로드캐스트 도메인을 분리해 네트워크 내 불필요한 트래픽을 감소시킨다.

---

#### 2. 동작 원리

- **IP 주소와 서브넷 마스크:**  
  IP 주소는 네트워크 부분과 호스트 부분으로 구성되며, 서브넷 마스크를 통해 어느 비트가 네트워크를, 어느 비트가 호스트를 나타내는지 구분한다.

  - 예를 들어, 192.168.1.0/24의 경우, 처음 24비트는 네트워크를 나타내고 나머지 8비트는 호스트 주소를 표현함.

- **서브넷 마스크의 재정의:**  
  서브네팅을 위해 기본 서브넷 마스크보다 더 많은 비트를 네트워크 부분으로 할당한다.

  - 예를 들어, /24 네트워크를 /26으로 나누면, 네트워크 부분이 26비트가 되고, 호스트 부분은 6비트가 되어 한 서브넷당 최대 2⁶ – 2 = 62개의 호스트 주소를 사용 가능.

---

### 17. ARP (Address Resolution Protocol)

IP 네트워크 내에서 IP 주소를 해당 호스트의 물리적 주소(즉, MAC 주소)로 매핑하기 위한 프로토콜. 주로 IPv4 환경에서 사용되며, 네트워크 계층의 논리 주소와 데이터 링크 계층의 물리 주소 간의 변환을 담당한다.

---

### 1. ARP의 기본 원리

- **목적:**  
  ARP는 IP 패킷을 목적지 MAC 주소로 캡슐화할 때 필요한 정보를 제공하여, 동일한 LAN 내의 통신이 이루어지도록 한다.

- **작동 계층:**  
  ARP는 OSI 모델에서 네트워크 계층(IP)과 데이터 링크 계층(MAC) 사이에서 동작하며, 주로 이더넷 네트워크에서 활용됨.

---

### 2. ARP 동작 과정

1. **ARP 캐시 확인:**

   - **설명:**  
     통신을 시작하기 전, 송신 호스트는 자신의 ARP 캐시에 대상 IP 주소에 해당하는 MAC 주소가 저장되어 있는지 확인한다.

2. **ARP 요청(ARP Request) 전송:**

   - **설명:**  
     ARP 캐시에 대상 IP에 대한 MAC 주소가 없는 경우, 송신 호스트는 네트워크 전체에 브로드캐스트로 ARP 요청 패킷을 전송한다.
   - **패킷 구성:**
     - **출발지 IP 및 MAC 주소:** 송신 호스트의 정보
     - **목적지 IP 주소:** 대상 호스트의 IP 주소
     - **목적지 MAC 주소:** 브로드캐스트 주소 (일반적으로 FF:FF:FF:FF:FF:FF)
   - **동작:**  
     네트워크에 연결된 모든 호스트는 이 ARP 요청 패킷을 수신하여, 자신이 해당 IP 주소와 일치하는지 확인한다.

3. **ARP 응답(ARP Reply) 전송:**

   - **설명:**  
     ARP 요청을 수신한 호스트 중, 요청한 IP 주소와 일치하는 호스트는 자신의 MAC 주소를 포함한 ARP 응답 패킷을 생성하여, 송신 호스트에 유니캐스트로 전송한다.
   - **패킷 구성:**
     - **출발지 IP 및 MAC 주소:** 응답 호스트의 정보
     - **목적지 IP 및 MAC 주소:** 요청 호스트의 정보
   - **동작:**  
     요청을 보낸 호스트는 ARP 응답을 수신하면, 해당 정보를 ARP 캐시에 저장하고 이후 통신에 활용함.

---

### 18. VLAN (Virtual LAN)

- 물리적 위치와 상관없이 논리적으로 네트워크를 분할하여, 보안, 관리, 트래픽 제어 등을 제공하는 기술.
- 구성 방식:
  - 포트 기반: 각 스위치 포트를 미리 정의된 VLAN에 할당하는 방식
  - 태그 기반: IEEE 802.1Q, 프레임에 추가 태그 정보를 삽입해 동일한 물리적 채널에서 여러 VLAN의 트래픽을 구분할 수 있도록 함

---

### 19. 스위치와 라우터의 차이

- **스위치:** 데이터 링크 계층(Layer 2)에서 작동하며, MAC 주소 기반으로 동일 LAN 내의 프레임을 전달합니다.
- **라우터:** 네트워크 계층(Layer 3)에서 작동하며, IP 주소 기반으로 서로 다른 네트워크 간의 패킷을 라우팅합니다.

---

### 20. ARQ (Automatic Repeat reQuest)

데이터 전송 과정에서 발생할 수 있는 오류를 자동으로 감지하고, 오류가 있는 데이터를 재전송하도록 요청하는 오류 제어 메커니즘

---

#### 1. ARQ의 기본 원리

- **목적:**  
  전송 중에 발생하는 오류(손상, 패킷 손실 등)를 감지하여, 오류가 있는 데이터 프레임에 대해 재전송을 요청함으로써 최종적으로 수신된 데이터의 무결성과 신뢰성을 보장한다.

- **기본 동작 방식:**  
  수신자는 수신한 데이터의 오류를 검출(Cyclic Redundancy Check, CRC 등)하고, 오류가 없으면 ACK(확인 응답)를 송신자에게 전송한다. 오류가 발견되거나 ACK를 지정 시간 내에 받지 못하면, 송신자는 해당 데이터를 재전송한다.

---

#### 2. ARQ의 대표적인 방식

##### 2.1. Stop-and-Wait ARQ

- **동작 과정:**

  1. **데이터 전송:** 송신자는 한 프레임을 전송한 후, 해당 프레임에 대한 ACK 응답 대기.
  2. **ACK 수신:** 수신자가 프레임을 정상적으로 수신하면 ACK를 송신자에게 전송.
  3. **타임아웃 및 재전송:** ACK를 받지 못하면, 타이머가 만료되어 송신자는 동일한 프레임을 재전송.

- **특징:**
  - 단순 구현
  - 채널 효율성이 낮을 수 있음(송신 후 대기 시간 존재)

---

##### 2.2. Go-Back-N ARQ

- **동작 과정:**

  1. **연속 전송:** 송신자는 여러 프레임을 연속적으로 전송할 수 있으며, 각 프레임에 순서 번호를 부여한다.
  2. **ACK 누락 또는 오류 검출:** 수신자가 특정 프레임에서 오류를 감지하거나 ACK를 받지 못하면, 해당 프레임부터 이후의 모든 프레임을 무효화한다.
  3. **재전송:** 송신자는 오류가 발생한 프레임부터 순차적으로 모든 프레임을 재전송.

- **특징:**
  - Stop-and-Wait 방식보다 채널 이용률이 높음
  - 오류가 발생한 경우 다수의 불필요한 재전송이 발생할 수 있음

---

##### 2.3. Selective Repeat ARQ

- **동작 과정:**

  1. **연속 전송:** 송신자는 여러 프레임을 연속적으로 전송하며, 각 프레임에 고유한 번호를 할당한다.
  2. **개별 ACK 처리:** 수신자는 각 프레임을 독립적으로 확인하고, 오류 없이 수신한 프레임에 대해서만 ACK를 송신한다.
  3. **부분 재전송:** 오류가 발생한 특정 프레임에 대해서만 재전송을 요청하고, 송신자는 해당 프레임만 재전송한다.

- **특징:**
  - 높은 채널 효율성을 제공하며, 불필요한 재전송을 최소화함
  - 송신자와 수신자 모두 복잡한 버퍼링 및 타이머 관리를 필요로 함

---

### 21. HTTP 메소드 4가지

- POST, GET, PUT, DELETE는 기본적인 CRUD 작업에 대응한다.

---

### 22. REST (Representational State Transfer)

- 자원을 URI로 식별하고, HTTP 메소드를 통해 상태(생성, 조회, 수정, 삭제)를 처리하는 아키텍처 스타일

---

### 23. CORS (Cross-Origin Resource Sharing)

웹 브라우저가 보안상의 이유로 기본적으로 동일 출처 정책(same-origin policy)을 적용하는 상황에서, Cross Origin 간의 리소스 공유를 허용하기 위해 도입된 표준 메커니즘

- **Cross Origin**: URL의 프로토콜, 도메인, 포트중 하나라도 다른 경우

---

#### 1. CORS의 기본 개념

- **동일 출처 정책과 한계:**  
  웹 브라우저는 기본적으로 클라이언트 사이드 스크립트가 자신과 동일한 출처의 리소스에만 접근하도록 제한한다.

- **CORS의 목적:**  
  CORS는 이러한 제한을 완화하여, 서버가 명시적으로 특정 출처의 요청을 허용할 때만 리소스를 공유할 수 있도록 한다. 서버 측에서 HTTP 응답 헤더를 통해 허용된 출처를 명시함으로써, 보안과 리소스 접근의 유연성을 보장한다.

---

#### 2. CORS 동작 원리 및 요청 과정

- **요청 헤더 및 응답 헤더:**

  - **Access-Control-Allow-Origin:**  
    서버는 어떤 출처에서의 요청을 허용하는지 명시함.
    ex) `Access-Control-Allow-Origin: https://example.com` 또는 모든 출처를 허용하기 위해 `*`를 사용할 수 있다.
  - **Access-Control-Allow-Methods:**  
    허용하는 HTTP 메소드(GET, POST, PUT, DELETE 등)를 지정한다.
  - **Access-Control-Allow-Headers:**  
    클라이언트가 요청 시 사용할 수 있는 헤더들을 명시한다.

- **Preflight 요청:**
  - **동작:**  
    단순 요청(Simple Request)이 아닌 경우(예: PUT, DELETE, 혹은 커스텀 헤더를 사용하는 요청) 브라우저는 실제 요청을 보내기 전에 OPTIONS 메소드로 Preflight 요청을 전송한다.
  - **목적:**  
    서버가 실제 요청을 수행하기 전에, 요청 방법, 헤더, 출처 등을 검증하여 클라이언트의 요청이 안전한지 확인하기 위함.
  - **응답:**  
    서버는 Preflight 요청에 대해 필요한 CORS 응답 헤더를 포함한 응답을 반환하고, 이를 통해 브라우저는 실제 요청을 진행할지 결정한다.

---

#### 3. CORS의 보안 및 활용 측면

- **보안 강화:**  
  CORS는 서버가 신뢰할 수 있는 출처에 대해서만 리소스 접근을 허용하도록 함으로써, 악의적인 사이트에서의 무분별한 데이터 접근을 방지한다.

- **유연한 리소스 공유:**  
  API 서버나 CDN과 같이 여러 출처에서 리소스에 접근해야 하는 환경에서, CORS를 통해 필요한 경우에만 접근을 허용할 수 있으므로, 서비스의 확장성과 유연성을 보장할 수 있다.

- **서버 측 설정:**  
  서버 관리자는 응답 헤더를 통해 세밀하게 접근 제어 정책을 정의할 수 있으며, 필요한 경우 인증 정보(예: Access-Control-Allow-Credentials)를 포함하여 보안을 더욱 강화할 수 있다.

---

### 24. DHCP (Dynamic Host Configuration Protocol)

- DHCP는 네트워크 내 클라이언트에게 IP 주소, 서브넷 마스크, 게이트웨이, DNS 서버 등의 정보를 자동으로 할당하는 것.

---

### 25. SSL 통신 과정

- TCP 연결 수립
- Client Hello: 클라이언트 암호화 스펙, 랜덤 값 전송
- Server Hello: 서버 인증서, 랜덤 값 전송
- 서버 인증서 검증
- Server Hello Done
- Pre-master secret 교환 및 대칭키 암호화 방식 결정
- 대칭키로 암호화 세션 생성

---

### 26. HTTP/2.0 설명

#### 1. 프로토콜 구조 및 전송 방식

- **HTTP/1.1**

  - **텍스트 기반:** 요청과 응답 메시지가 텍스트 형식으로 구성됨.
  - **연결 재사용:** 한 번에 하나의 요청만 처리 가능합니다.
  - **헤드오브라인 차단:** 하나의 요청이 지연되면 후속 요청까지 영향을 받는다.

- **HTTP/2.0**
  - **이진 프로토콜:** 메시지가 이진 프레임 단위로 전송되어, 파싱 및 처리 효율 향상.
  - **멀티플렉싱:** 하나의 TCP 연결에서 여러 스트림을 동시에 처리할 수 있어, 한 스트림의 지연이 전체 연결에 영향을 주지 않음.
  - **헤더 압축:** HPACK 알고리즘을 이용하여 헤더 정보를 압축함으로써 오버헤드를 크게 줄임.

---

#### 2. 성능 및 효율성

- **HTTP/1.1**

  - **순차적 요청 처리:** 연결 당 단일 요청 처리로 인해 대량의 리소스를 동시에 요청할 때 지연이 발생할 수 있다.
  - **불필요한 연결 생성:** 여러 리소스를 요청할 경우, 다수의 연결을 생성하거나 연결 재사용에 따른 대기 시간이 발생할 수 있다.

- **HTTP/2.0**
  - **동시 요청 처리:** 멀티플렉싱으로 여러 요청/응답을 동시에 전송할 수 있어, 페이지 로딩 속도와 대역폭 활용도가 높아진다.
  - **서버 푸시:** 서버가 클라이언트가 필요로 할 추가 리소스를 미리 전송할 수 있어, 초기 로딩 시간을 단축시킬 수 있다.

---

### 27. 프록시 서버의 기능

### 프록시 서버 (Proxy Server)

- **개념 및 역할:**  
  내부 네트워크의 클라이언트가 외부 인터넷 리소스에 접근할 때, 요청을 대신 전달하고 응답을 수신하는 중계 서버.
- **주요 기능:**
  - **익명화:** 클라이언트의 IP 주소를 숨겨 보안을 강화한다.
  - **캐싱:** 자주 요청되는 리소스를 캐싱하여 응답 속도를 향상시키고, 대역폭 사용량을 절감한다.
  - **콘텐츠 필터링:** 특정 웹 사이트나 콘텐츠에 대한 접근을 제한하거나 관리한다.
  - **접근 제어:** 네트워크 사용자들의 인터넷 사용을 모니터링하고 제어할 수 있다

---

#### 리버스 프록시 서버 (Reverse Proxy Server)

- **개념 및 역할:**  
  외부 클라이언트의 요청을 받아 내부 서버(예: 웹 서버, 애플리케이션 서버)로 전달하는 역할을 한다.
- **주요 기능:**
  - **부하 분산:** 여러 내부 서버로 클라이언트 요청을 분산하여 시스템의 효율성과 안정성을 높인다.
  - **보안 강화:** 내부 서버의 구조와 IP 주소를 외부에 노출하지 않고, 요청을 필터링하거나 SSL 종료(Offloading) 기능을 제공하여 보안을 강화한다.
  - **캐싱:** 자주 요청되는 정적 콘텐츠를 캐싱하여 응답 속도를 개선하고, 서버 부하를 줄임.
  - **SSL/TLS 암호화 관리:** SSL 인증서 관리를 중앙화하여 보안 연결을 효율적으로 처리할 수 있다.

---

#### 핵심 차이점

- **위치와 방향:**

  - **프록시 서버:** 클라이언트와 외부 서버 사이에 위치하여, 클라이언트의 요청을 외부로 전달하고 응답을 수신.
  - **리버스 프록시 서버:** 외부 클라이언트와 내부 서버 사이에 위치하여, 외부 요청을 내부 서버로 분산시키고 내부 서버의 정보를 숨김.

- **주요 목적:**
  - **프록시 서버:** 클라이언트의 보안, 캐싱, 콘텐츠 필터링, 익명성 유지 등.
  - **리버스 프록시 서버:** 부하 분산, 내부 서버 보호, SSL 오프로드 및 응답 시간 개선 등.

---

### 28. Unicast, Multicast, Broadcast

- **Unicast:** 한 송신자가 단일 수신자에게 데이터를 전송
- **Multicast:** 한 송신자가 다수의 지정된 수신자 그룹에게 데이터를 전송
- **Broadcast:** 한 송신자가 동일 네트워크상의 모든 호스트에게 데이터를 전송

---

### 29. 웹 소켓(WebSocket)

- TCP를 기반으로 하며 지속적인 연결을 유지하여, 양방향 실시간 통신을 가능하게 하는 프로토콜.

---

### 30. XSS (Cross-Site Scripting)

- XSS는 공격자가 악의적인 스크립트를 웹 애플리케이션에 삽입하여, 사용자 브라우저에서 실행되도록 유도함으로써 쿠키 탈취, 세션 하이재킹 등 다양한 공격을 유발할 수 있는 보안 취약점입니다.

---

### 31. Big Endian과 Little Endian

- Big: MSB가 메모리의 낮은 주소에 존재
- Little: MSB가 메모리의 높은 주소에 존재

---

### 32. Sliding Window

- TCP의 슬라이딩 윈도우 알고리즘은 송신측이 전송한 데이터 중 아직 확인(ACK)을 받지 않은 부분과 수신측의 버퍼 상황을 고려하여, 한 번에 전송할 수 있는 데이터 양을 동적으로 조절하는 메커니즘.

---

### 33. 이더넷

- 이더넷은 LAN 환경에서 널리 사용되는 기술로, 프레임 단위의 데이터 전송을 수행하며, CSMA/CD(Carrier Sense Multiple Access with Collision Detection) 방식을 사용해 충돌을 감지하고 네트워크 효율성을 유지한다.

---

### 34. 쿠키(Cookie)와 세션(Session)의 차이점

- **보완 사항:**
  - **쿠키:** 클라이언트 측(웹 브라우저)에 저장되는 작은 데이터 조각으로, 상태 정보를 유지하거나 사용자 식별에 활용됩니다.
  - **세션:** 서버 측에서 관리되는 사용자 상태 정보로, 일반적으로 쿠키를 통해 세션 ID를 전달하여, 보다 안전하게 사용자 정보를 관리합니다.

---

### 35. DNS (Domain Name System)

- **보완 사항:**
  - DNS는 도메인 이름을 IP 주소로 변환하는 분산형 네임 시스템으로, 인터넷 상의 주소 체계를 관리하고, 사용자가 기억하기 쉬운 이름을 통해 서버에 접근할 수 있도록 한다.

---

### 36. 포트와 소켓

- **포트:** IP 주소와 결합하여, 특정 애플리케이션 프로세스를 식별하는 논리적 주소 역할을 한다.
- **소켓:** 네트워크 통신의 끝점으로, IP 주소와 포트를 포함하여 클라이언트와 서버 간의 연결을 형성하는 인터페이스.

---

### 37. JWT (JSON Web Token)

클라이언트와 서버 간의 정보를 안전하게 전송하기 위해 널리 사용되는 개방형 표준(RFC 7519). 주로 인증 및 권한 부여 과정에서 사용된다.

---

#### 1. JWT의 기본 개념

- **자체 포함(Self-contained):**  
  JWT는 토큰 내부에 필요한 모든 정보를 담고 있어, 서버 측에서 별도의 세션 저장소 없이도 사용자 인증 상태를 확인할 수 있다.

- **경량 및 확장성:**  
  JSON 형식으로 인코딩되어 전송되므로, 네트워크 대역폭을 효율적으로 사용할 수 있으며, 다양한 클라이언트와 서버 환경에서 쉽게 활용된다.

- **보안성:**  
  토큰은 비밀 키(HS256 등) 또는 공개/개인키 쌍(RS256 등)을 이용해 서명되거나 암호화되어, 데이터 무결성과 인증이 보장된다.

---

### 2. JWT의 구성 요소

JWT는 점(.)으로 구분된 세 부분으로 구성된다.

1. **헤더(Header):**

   - **구성:**  
     토큰의 유형(typ)과 서명 알고리즘(alg) 명시
   - **예시:**
     ```json
     {
       "alg": "HS256",
       "typ": "JWT"
     }
     ```

2. **페이로드(Payload):**

   - **구성:**  
     사용자의 식별 정보 및 토큰의 만료 시간(exp), 발행 시간(iat), 발행자(iss) 등의 클레임(Claim)들을 포함한다
   - **클레임 유형:**
     - **등록된 클레임(Registered Claims):** 표준화된 클레임(예: iss, exp, sub 등)
     - **공개 클레임(Public Claims):** 사용자 정의로 설정 가능한 클레임
     - **비공개 클레임(Private Claims):** 양 당사자 간에 협의된 클레임
   - **예시:**
     ```json
     {
       "sub": "1234567890",
       "name": "John Doe",
       "iat": 1516239022
     }
     ```

3. **서명(Signature):**
   - **생성 방법:**  
     인코딩된 헤더와 페이로드를 결합한 후, 지정된 알고리즘과 비밀 키 또는 개인 키를 사용하여 생성한다.
   - **목적:**  
     토큰의 무결성을 보장하며, 클라이언트와 서버가 공유하는 비밀 키 또는 공개/개인키를 통해 토큰의 진위를 확인할 수 있다.

---

#### 3. JWT의 동작 방식

1. **토큰 발급:**  
   사용자가 로그인 등의 인증 과정을 완료하면, 서버는 사용자의 정보와 관련된 클레임을 담은 JWT를 생성하고, 서명 후 클라이언트에게 발급한다.

2. **토큰 전송:**  
   클라이언트는 이후의 요청 시 HTTP 헤더(예: Authorization: Bearer {JWT})에 JWT를 포함하여 서버로 전송한다.

3. **토큰 검증:**  
   서버는 수신한 JWT의 서명을 검증하여 토큰이 변조되지 않았음을 확인하고, 페이로드 내의 클레임(예: 만료 시간 등)을 체크하여 사용자의 인증 상태를 확인한다.

4. **자원 접근:**  
   인증이 성공하면, 서버는 해당 클라이언트에게 요청한 자원이나 서비스를 제공한다.

---

### 4. JWT의 활용 사례

- **인증 및 권한 부여:**  
  웹 애플리케이션, 모바일 앱 등에서 사용자 로그인 후 세션 정보를 유지하는 데 사용되며, stateless 환경에서 효율적인 인증 처리가 가능하다.

- **API 보안:**  
  RESTful API 호출 시, 토큰 기반 인증을 통해 클라이언트의 접근 권한을 검증하고, 외부 애플리케이션과의 안전한 통신을 보장한다.

- **싱글 사인온(SSO):**  
  여러 애플리케이션 간의 사용자 인증 정보를 통합 관리하여, 한 번의 로그인으로 여러 서비스에 접근할 수 있도록 지원한다.

---

#### 40. 공인 IP와 사설 IP

- **공인 IP:** 전 세계적으로 고유하게 할당되어 인터넷 상에서 직접 식별되는 주소
- **사설 IP:** 내부 네트워크에서 사용되며, NAT(Network Address Translation)를 통해 공인 IP와 매핑되어 외부와 통신

---

[질문 참고 1](https://kjsu0209.github.io/Tech-Interview/network/network)
[질문 참고 2](https://dev-coco.tistory.com/161)

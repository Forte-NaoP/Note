# 운영체제 질문 모음

---

### 1. 프로세스와 스레드의 차이

<details>
<summary>접기/펼치기</summary>

- **프로세스:** 독립된 메모리 공간과 시스템 자원을 할당받으며 실행되는 프로그램의 인스턴스
- **스레드:** 프로세스 내의 실행 단위로, 동일한 주소 공간 및 자원을 공유한다.

</details>

---

### 2. LRU 캐싱

<details>
<summary>접기/펼치기</summary>

- **LRU(Least Recently Used) 캐싱:** 가장 최근에 참조되지 않은 페이지를 우선적으로 교체하는 기법

</details>

---

### 3. Race Condition

<details>
<summary>접기/펼치기</summary>

- **Race Condition:** 여러 프로세스나 스레드가 공유 자원에 동시에 접근하여, 실행 순서에 따라 결과가 달라지는 현상

</details>

---

### 4. 데드락이란

<details>
<summary>접기/펼치기</summary>

- **데드락:** 둘 이상의 프로세스나 스레드가 서로가 점유한 자원을 요청하며, 무한 대기 상태에 빠지는 현상

</details>

---

### 5. 데드락의 해결 방법

<details>
<summary>접기/펼치기</summary>

- **예방:** 상호 배제, 순환 대기, 점유 대기, 비선점 조건 중 하나를 없앤다.
- **회피:** 은행원 알고리즘, 자원 할당 그래프를 통해 데드락 발생 가능성 탐지 후 회피

</details>

---

### 6. 인터럽트와 트랩

<details>
<summary>접기/펼치기</summary>

- **인터럽트:** 하드웨어나 외부 이벤트에 의해 발생하며, 현재 실행 중인 프로세스의 흐름을 중단하고 처리가 필요한 이벤트를 처리한다.
- **트랩:** 프로그램 실행 중 발생한 시스템 호출이나 예외 상황에 의해 유발되며, 운영체제가 해당 상황을 처리하기 위해 제어를 넘긴다.

</details>

---

### 7. Process 상태 변화 과정

<details>
<summary>접기/펼치기</summary>

- Ready, Running, Waiting, Exit

</details>

---

### 8. 페이징

<details>
<summary>접기/펼치기</summary>

- **페이징:** 논리적 주소 공간을 고정 크기의 페이지로, 물리적 메모리를 동일한 크기의 프레임으로 나누어 관리하는 기법. 이로 인해 외부 단편화는 없으나, 마지막 페이지에서 내부 단편화가 발생할 수 있다.

</details>

---

### 9. 페이지 교체 알고리즘의 종류

<details>
<summary>접기/펼치기</summary>

- **LRU:** 가장 오랫동안 참조되지 않은 페이지를 교체.
- **LFU:** 참조 빈도가 가장 낮은 페이지를 교체.
- **OPT:** 미래에 사용되지 않을 것으로 예상되는 페이지를 교체하는 최적 알고리즘.

</details>

---

### 10. 메모리구조

<details>
<summary>접기/펼치기</summary>

- Code(프로그램 명령어), Data(전역 변수 등), Heap(동적 할당 메모리), Stack(함수 호출 및 지역 변수)

</details>

---

### 11. 뮤텍스와 세마포어의 차이

<details>
<summary>접기/펼치기</summary>

- **뮤텍스:** 단 하나의 프로세스나 스레드만 접근할 수 있도록 하며, 락을 건 주체가 반드시 해제해야 한다.
- **세마포어:** 동시 접근 가능한 프로세스 수를 조절하며, 다른 스레드에 의해서도 해제가 가능하고, 지정된 카운트(0 이상의 정수)를 가짐.

</details>

---

### 12. 커널모드와 유저모드

<details>
<summary>접기/펼치기</summary>

- **커널모드:** 운영체제 핵심 기능(프로세스, 메모리, I/O 등)을 실행하며, 하드웨어 자원에 대한 직접 접근이 허용되는 모드.
- **유저모드:** 응용 프로그램이 실행되는 모드로, 시스템 자원에 대한 직접 접근은 제한되며, 커널을 통해 간접적으로 자원을 사용한다.

</details>

---

### 13. Round Robin 스케줄링

<details>
<summary>접기/펼치기</summary>

- **Round Robin:** 각 프로세스에 동일한 시간 할당량(Time Quantum)을 부여하여 순환하며 실행시키는 스케줄링 기법

</details>

---

### 14. PC(Program Counter)의 역할

<details>
<summary>접기/펼치기</summary>

- 현재 실행중인 프로세스의 다음 실행할 명령어 주소를 저장함

</details>

---

### 15. 세그멘테이션

<details>
<summary>접기/펼치기</summary>

- **세그멘테이션:** 프로그램을 의미 단위(코드, 데이터, 스택 등)로 나누어 가변 크기의 세그먼트로 관리하며, 각 세그먼트별로 보호 및 권한 설정이 가능하다. 단, 외부 단편화가 발생할 수 있다.

</details>

---

### 16. 가상 메모리

<details>
<summary>접기/펼치기</summary>

- **가상 메모리:** 프로세스가 물리 메모리보다 큰 주소 공간을 사용할 수 있도록 하며, 필요 시 페이지 단위로 디스크와 메모리 간의 데이터 전환을 통해 실행됩니다.

</details>

---

### 17. 동기와 비동기

<details>
<summary>접기/펼치기</summary>

- **동기(Synchronous):** 작업이 순차적으로 실행되어, 이전 작업이 완료되어야 다음 작업이 진행되는 방식
- **비동기(Asynchronous):** 작업이 독립적으로 실행되며, 완료 여부와 관계없이 다음 작업이 진행될 수 있는 방식

</details>

---

### 18. Critical Section의 3요소

<details>
<summary>접기/펼치기</summary>

- **세 가지 조건:**
  1. **상호 배제(Mutual Exclusion):** 한 번에 하나의 프로세스만 임계 구역에 접근 가능
  2. **진행(Progress):** 임계 구역에 접근할 프로세스가 있을 때, 불필요한 지연이 없어야 함
  3. **한정 대기(Bounded Waiting):** 각 프로세스가 임계 구역에 접근할 수 있는 기회가 유한함

</details>

---

### 19. IPC(Inter Process Communication)와 구현 방법

<details>
<summary>접기/펼치기</summary>

- **IPC:** 프로세스 간 데이터를 교환하거나 협업하기 위한 메커니즘으로, 대표적으로 파이프(익명/네임드), 공유 메모리, 소켓, 메시지 큐, Signal 등이 있다.

</details>

---

### 20. 콘보이 현상 및 발생 가능한 스케줄러 알고리즘

<details>
<summary>접기/펼치기</summary>

- **콘보이 현상:** 한 프로세스의 긴 작업 시간 때문에 뒤따르는 짧은 프로세스들이 불필요하게 대기하는 현상으로, 주로 **FCFS(First-Come, First-Served)** 스케줄링에서 발생

</details>

---

### 21. 선점형 스케줄링과 비선점형 스케줄링

<details>
<summary>접기/펼치기</summary>

- **선점형 스케줄링:** 운영체제가 실행 중인 프로세스를 강제로 중단시키고 다른 프로세스에 CPU를 할당할 수 있다.
- **비선점형 스케줄링:** 실행 중인 프로세스가 자발적으로 CPU를 반납할 때까지 계속 실행된다.

</details>

---

### 22. Context Switching

<details>
<summary>접기/펼치기</summary>

- **Context Switching:** CPU가 현재 실행 중인 프로세스의 상태(context)를 저장한 후, 다른 프로세스의 상태를 불러와 실행하는 전환 과정.

</details>

---

### 23. 지역성의 두 가지

<details>
<summary>접기/펼치기</summary>

- **시간 지역성:** 최근에 사용된 데이터는 가까운 미래에도 재사용될 가능성이 높다.
- **공간 지역성:** 특정 메모리 주소가 참조되면, 그 주변 주소도 함께 참조될 가능성이 높다.

</details>

---

### 24. Spin Lock과 Busy Waiting

<details>
<summary>접기/펼치기</summary>

- **Spin Lock:** 락 획득을 위해 짧은 시간 동안 반복적으로 상태를 확인하며, 대기하는 동안 CPU를 계속 사용.
- **Busy Waiting:** 조건이 만족될 때까지 반복해서 확인하는 방식으로, CPU 자원을 낭비할 수 있는 대기 기법.

</details>

---

### 25. 캐시 매핑 방식 3가지

<details>
<summary>접기/펼치기</summary>

- **캐시 매핑 방식:**
  - **직접 매핑(Direct Mapping):** 각 메모리 블록이 캐시의 한정된 위치에만 저장됨
  - **완전 연관 매핑(Fully Associative Mapping):** 어느 캐시 슬롯에도 저장이 가능한 방식
  - **집합 연관 매핑(Set-Associative Mapping):** 직접 매핑과 완전 연관 매핑의 중간 형태로, 캐시를 여러 집합으로 나누어 관리

</details>

---

### 26. 프로세스 관련 시스템콜

<details>
<summary>접기/펼치기</summary>

- **fork():** 새로운 자식 프로세스를 생성
- **wait():** 자식 프로세스의 종료를 대기
- **exec() 패밀리:** 현재 프로세스의 메모리를 새 프로그램으로 대체
- **exit():** 프로세스 종료

</details>

---

### 27. 메모리 할당 알고리즘 (First Fit, Next Fit, Best Fit)

<details>
<summary>접기/펼치기</summary>

- **First Fit:** 메모리의 시작부터 탐색하여, 첫 번째로 충분한 공간을 찾아 할당
- **Next Fit:** 마지막 할당 지점 이후부터 순환적으로 탐색하여, 충분한 공간을 찾아 할당
- **Best Fit:** 할당 후 남는 내부 단편화를 최소화하기 위해, 필요한 크기에 가장 근접한 작은 공간을 선택하여 할당

</details>

---

### 28. 커널에 대한 설명

<details>
<summary>접기/펼치기</summary>

- **커널:** 운영체제의 핵심 구성 요소로, 하드웨어와 응용 프로그램 간의 인터페이스 역할을 수행하며, 프로세스 관리, 메모리 관리, 파일 시스템, I/O 제어 등 주요 기능을 제공합니다.

</details>

---

### 29. Page Fault

<details>
<summary>접기/펼치기</summary>

- **Page Fault:** 프로세스가 접근하려는 페이지가 메인 메모리에 존재하지 않아, 디스크에서 해당 페이지를 로드해야 하는 상황입니다. 이때, 메모리 공간이 부족하면 페이지 교체 알고리즘(예: FIFO, OPT, LRU, LFU 등)을 통해 교체가 이루어집니다.
- **쓰기 정책:** 페이지 수정 여부를 판단하기 위해 dirty bit를 사용하며, 필요 시 디스크에 기록합니다.

</details>

---

### 30. Busy Waiting 해결 방법

<details>
<summary>접기/펼치기</summary>

- **Busy Waiting 해결:**
  - **블로킹(Block):** 조건이 만족될 때까지 프로세스를 대기 상태로 전환하여 CPU 자원 낭비를 방지
  - **세마포어, 뮤텍스:** 동기화 도구를 사용하여, 불필요한 반복 확인 대신 적절한 신호를 통해 프로세스 전환
  - **이벤트 기반 처리:** 인터럽트나 이벤트를 통해 대기 중인 프로세스가 재개되도록 설계

</details>

---

### 31. 요구 페이징

<details>
<summary>접기/펼치기</summary>

- **요구 페이징(Demand Paging):** 프로세스 실행 시 전체 페이지를 미리 로드하지 않고, 페이지 접근 요청이 있을 때마다 해당 페이지를 메모리에 적재하는 방식으로, 메모리 사용의 효율성을 높인다.

</details>

---

[질문 출처](https://kjsu0209.github.io/Tech-Interview/operating-system/os)

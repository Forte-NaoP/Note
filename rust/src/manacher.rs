use std::cmp::min;

fn manacher(s: Vec<u8>) -> u64 {
    let e = s.len() * 2 + 1;
    let mut extended = vec![0; e];
    for i in 0..s.len() {
        extended[i * 2 + 1] = s[i];
    }
    let mut r = 0; // 현재까지의 팰린드롬 중 가장 긴 것의 오른쪽 끝
    let mut p = 0; // 현재까지의 팰린드롬 중 가장 긴 것의 중심
    let mut dp = vec![0; e];
    let mut ans = 0;
    for i in 0..e {
        // DP[i] 초기화
        // i > r 이라면 검증된 팰린드롬을 벗어났음을 의미 => DP[i] = 0
        // 이외의 경우, 다음과 같은 3가지 케이스가 존재
        // 1) 현재 문자 기준 팰린드롬이 검증된 가장 긴 팰린드롬 안에 존재 
        //    - p를 기준으로 현재 문자 i의 대칭점(2 * p - i)과 동일한 길이만큼 팰린드롬임이 보장됨
        //    - 따라서 DP[i] = DP[2 * p - i]
        // 2) 현재 문자 기준 팰린드롬이 검증된 가장 긴 팰린드롬과 겹치는 경우
        //    - 검증된 가장 긴 팰린드롬까지는 팰린드롬임이 보장됨
        //    - 따라서 DP[i] = r - i
        // 3) 현재 문자 기준 팰린드롬이 검증된 가장 긴 팰린드롬을 넘어가는 경우
        //    - 검증된 가장 긴 팰린드롬까지는 팰린드롬임이 보장됨
        //    - 따라서 DP[i] = r - i
        //
        // 1)의 경우 DP[2 * p - i] < r - i (검증된 가장 긴 팰린드롬을 넘어가지 않아야 하므로)
        // 2), 3)의 경우 r - i <= DP[2 * p - i] (검증된 가장 긴 팰린드롬과 겹치거나 넘어가야 하므로)
        // => DP[2 * p - i] 와 r - i 중 작은 값으로 초기화
        // 출처 : https://sam0308.tistory.com/127
        if i <= r {
            dp[i] = min(dp[p * 2 - i], r - i);
        }

        // 팰린드롬 확장
        while 
            i >= dp[i] + 1 && // 현재 문자 i 기준 좌측 끝 (i - dp[i] - 1 >= 0)
            i + dp[i] + 1 < e && // 현재 문자 i 기준 우측 끝 
            extended[i - dp[i] - 1] == extended[i + dp[i] + 1] {
            dp[i] += 1;
        }

        // 팰린드롬 확장 반영
        if r < i + dp[i] {
            r = i + dp[i];
            p = i;
        }
        ans += (dp[i] + 1) as u64 / 2;
    }
    ans
}